diff --git a/configure.ac b/configure.ac
index 11c46ff..aa454cd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -55,6 +55,10 @@ fi
 
 AC_CANONICAL_HOST
 
+#check if libxrl should be built as a convenience library
+AC_ARG_ENABLE([libxrl],[AS_HELP_STRING([--disable-libxrl],[do not build libxrl separately, link it statically into bindings])],[enable_libxrl=$enableval],[enable_libxrl=check])
+
+AM_CONDITIONAL([LIBXRL_CONVENIENCE_BUILD], [test x$enable_libxrl = xno])
 
 #headers check
 AC_CHECK_HEADERS([math.h stdio.h stdlib.h string.h ctype.h stddef.h locale.h])
@@ -106,23 +110,26 @@ if test "x$host" != "x$build" ; then
 		AC_MSG_ERROR([wine is necessary when cross-compiling for windows.])
 	fi
 	CROSS_COMPILING=yes
-	LDFLAGS+="-no-undefined"
-	LDFLAGS_LIBXRL=-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def
+	LDFLAGS_LIBXRL="-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def -no-undefined"
+	LDFLAGS_FORTRAN="-no-undefined"
+	LDFLAGS_PYTHON="-no-undefined -Wl,-subsystem,windows"
 else
 	case "$host" in
 		i686-*mingw*)
 			#build dll
-			LDFLAGS+="-no-undefined"
-			LDFLAGS_LIBXRL=-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def
+			LDFLAGS_LIBXRL="-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def -no-undefined"
 			OS_WINDOWS_32=1
 			OS_WINDOWS=1
+			LDFLAGS_FORTRAN="-no-undefined"
+			LDFLAGS_PYTHON="-no-undefined -Wl,-subsystem,windows"
 			;;
 		x86_64-*mingw*)
 			#build dll
-			LDFLAGS+="-no-undefined"
-			LDFLAGS_LIBXRL=-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def
+			LDFLAGS_LIBXRL="-Wl,--output-def,libxrl-$LIB_CURRENT_MINUS_AGE.def -no-undefined"
 			OS_WINDOWS_64=1
 			OS_WINDOWS=1
+			LDFLAGS_FORTRAN="-no-undefined"
+			LDFLAGS_PYTHON="-no-undefined -Wl,-subsystem,windows"
 			;;
 	esac
 fi
@@ -135,6 +142,8 @@ AC_SUBST(OS_WINDOWS_64)
 
 
 AC_SUBST(LDFLAGS_LIBXRL)
+AC_SUBST(LDFLAGS_FORTRAN)
+AC_SUBST(LDFLAGS_PYTHON)
 
 
 
@@ -487,8 +496,25 @@ elif test "x$SWIG" = xswig && test "x$enable_python" != xno && test "x$DISABLE_B
 			fi
 			VALID_PYTHON=no
 		else
-			VALID_PYTHON=yes
-			AC_MSG_NOTICE([Building with Python bindings])
+			# check for numpy!
+			AC_MSG_CHECKING([for numpy])
+			res=`$PYTHON -c "import numpy" &>/dev/null`
+			NUMPY=$?
+			if test x$NUMPY = x0 ; then
+				AC_MSG_RESULT([yes])
+				NUMPY_HEADERS_PATH=`$PYTHON -c "from __future__ import print_function; import numpy; \
+					print(numpy.get_include())"`
+				if test $OS_WINDOWS = 1 ; then
+					NUMPY_HEADERS_PATH=`cygpath -u $NUMPY_HEADERS_PATH`
+				fi
+				NUMPY_HEADERS=-I$NUMPY_HEADERS_PATH
+				AC_SUBST(NUMPY_HEADERS)
+				VALID_PYTHON=yes
+				AC_MSG_NOTICE([Building with Python bindings])
+			else
+				VALID_PYTHON=no
+				AC_MSG_RESULT([no])
+			fi
 		fi
 
 	fi
@@ -523,7 +549,24 @@ if test "x$enable_python_np" != xno && test  "x$DISABLE_BINDINGS" = xno  ; then
 				fi
 				VALID_PYTHON_EXE=no
 			else
-				VALID_PYTHON_EXE=yes
+				# check for numpy!
+				AC_MSG_CHECKING([for numpy])
+				res=`$PYTHON -c "import numpy" &>/dev/null`
+				NUMPY=$?
+				if test x$NUMPY = x0 ; then
+					AC_MSG_RESULT([yes])
+					NUMPY_HEADERS_PATH=`$PYTHON -c "from __future__ import print_function; import numpy; \
+						print(numpy.get_include())"`
+					if test $OS_WINDOWS = 1 ; then
+						NUMPY_HEADERS_PATH=`cygpath -u $NUMPY_HEADERS_PATH`
+					fi
+					NUMPY_HEADERS=-I$NUMPY_HEADERS_PATH
+					AC_SUBST(NUMPY_HEADERS)
+					VALID_PYTHON_EXE=yes
+				else
+					VALID_PYTHON_EXE=no
+					AC_MSG_RESULT([no])
+				fi
 			fi
 		fi
 	else
@@ -532,19 +575,7 @@ if test "x$enable_python_np" != xno && test  "x$DISABLE_BINDINGS" = xno  ; then
 	if test "x$VALID_PYTHON_EXE" = xyes ; then
 		#now check cython
 		AC_CHECK_PROGS(CYTHON, [cython-[$PYTHON_VERSION] cython],["nocython"])
-		#check for numpy
-		AC_MSG_CHECKING([for numpy])
-		res=`$PYTHON -c "import numpy" &>/dev/null`
-		NUMPY=$?
-		if test x$NUMPY = x0 ; then
-			AC_MSG_RESULT([yes])
-			NUMPY_HEADERS=-I`$PYTHON -c "from __future__ import print_function; import numpy; \
-				print(numpy.get_include())"`
-			AC_SUBST(NUMPY_HEADERS)
-		else
-			AC_MSG_RESULT([no])
-		fi
-		if test x$CYTHON != "xnocython" && test x$NUMPY = x0 ; then
+		if test x$CYTHON != "xnocython" ; then
 			VALID_PYTHON_NUMPY=yes
 			AC_MSG_NOTICE([Building with Python-NumPy bindings])
 		elif test "x$enable_python_np" = "xyes" ; then
diff --git a/m4/m4-ax_python_devel.m4 b/m4/m4-ax_python_devel.m4
index f7e8166..c52a0f5 100644
--- a/m4/m4-ax_python_devel.m4
+++ b/m4/m4-ax_python_devel.m4
@@ -170,6 +170,9 @@ $ac_distutils_result])
 			if test "${plat_python_path}" != "${python_path}"; then
 				python_path="-I$python_path -I$plat_python_path"
 			else
+				if test $OS_WINDOWS = 1 ; then
+					python_path=`cygpath -u $python_path`
+				fi
 				python_path="-I$python_path"
 			fi
 		fi
@@ -239,6 +242,10 @@ EOD`
 		#then
 			# use the official shared library
 			ac_python_library=`echo "$ac_python_library" | sed "s/^lib//"`
+			if test -z "$ac_python_libdir" ; then
+				full_python=`which $PYTHON`
+				ac_python_libdir=`AS_DIRNAME($full_python)`
+			fi
 			PYTHON_LDFLAGS="-L$ac_python_libdir -l$ac_python_library"
 		#else
 		#	# old way: use libpython from python_configdir
@@ -270,6 +277,9 @@ EOD`
 	if test -z "$PYTHON_SITE_PKG"; then
 		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_lib(0,0));"`
+		if test $OS_WINDOWS = 1 ; then
+			PYTHON_SITE_PKG=`cygpath -u $PYTHON_SITE_PKG`
+		fi
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
@@ -281,6 +291,9 @@ EOD`
 	if test -z "$PYTHON_SITE_PKG_EXEC"; then
 		PYTHON_SITE_PKG_EXEC=`$PYTHON -c "import distutils.sysconfig; \
 		        print (distutils.sysconfig.get_python_lib(1,0));"`
+		if test $OS_WINDOWS = 1 ; then
+			PYTHON_SITE_PKG_EXEC=`cygpath -u $PYTHON_SITE_PKG_EXEC`
+		fi
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG_EXEC])
 	AC_SUBST([PYTHON_SITE_PKG_EXEC])
@@ -290,13 +303,31 @@ EOD`
 	#
 	AC_MSG_CHECKING([for Python module cflags])
 	if test -z "$PYTHON_CFLAGS"; then
-		PYTHON_CFLAGS=[`$PYTHON -c "import distutils.sysconfig; \
-		        conf = distutils.sysconfig.get_config_vars(); \
-			print (conf['OPT'])"`]
+		PYTHON_CFLAGS=`cat<<EOD | $PYTHON -
+from distutils.sysconfig import *
+e = get_config_var('OPT')
+if e is not None:
+  print(e)
+EOD`
 	fi
 	AC_MSG_RESULT([$PYTHON_CFLAGS])
 	AC_SUBST([PYTHON_CFLAGS])
 
+	#
+	# Check for module extension
+	#
+	AC_MSG_CHECKING([for Python module extension])
+	if test -z "$PYTHON_EXT"; then
+		PYTHON_EXT=`cat<<EOD | $PYTHON -
+from distutils.sysconfig import *
+e = get_config_var('SO')
+if e is not None:
+  print(e)
+EOD`
+	fi
+	AC_MSG_RESULT([$PYTHON_EXT])
+	AC_SUBST([PYTHON_EXT])
+
 
 	#
 	# libraries which must be linked in when embedding
@@ -317,8 +348,10 @@ EOD`
 	# save current global flags
 	ac_save_LIBS="$LIBS"
 	ac_save_CPPFLAGS="$CPPFLAGS"
+	ac_save_LDFLAGS="$LDFLAGS"
 	LIBS="$ac_save_LIBS $PYTHON_LDFLAGS $PYTHON_EXTRA_LIBS"
 	CPPFLAGS="$ac_save_CPPFLAGS $PYTHON_CPPFLAGS"
+	LDFLAGS=""
 	AC_LANG_PUSH([C])
 	AC_LINK_IFELSE([
 		AC_LANG_PROGRAM([[#include <Python.h>]],
@@ -327,6 +360,7 @@ EOD`
 	AC_LANG_POP([C])
 	# turn back to default flags
 	CPPFLAGS="$ac_save_CPPFLAGS"
+	LDFLAGS="$ac_save_LDFLAGS"
 	LIBS="$ac_save_LIBS"
 
 	AC_MSG_RESULT([$pythonexists])
diff --git a/python/Makefile.am b/python/Makefile.am
index c8e3c34..cb4975a 100644
--- a/python/Makefile.am
+++ b/python/Makefile.am
@@ -18,10 +18,14 @@ pyexec_LTLIBRARIES =
 
 if ENABLE_PYTHON
 pyexec_LTLIBRARIES += _xraylib.la
-_xraylib_la_CFLAGS = $(PYTHON_CFLAGS) -I$(top_srcdir)/include $(PYTHON_CPPFLAGS) 
+_xraylib_la_CFLAGS = $(PYTHON_CFLAGS) -I$(top_srcdir)/include $(PYTHON_CPPFLAGS) $(NUMPY_HEADERS)
 _xraylib_la_LIBADD = ../src/libxrl.la
 nodist__xraylib_la_SOURCES = xraylib_wrap.c
-_xraylib_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
+_xraylib_la_LDFLAGS = $(LDFLAGS_PYTHON) -avoid-version -module -shared -export-dynamic -shrext $(PYTHON_EXT)
+if OS_WINDOWS
+_xraylib_la_LDFLAGS += $(PYTHON_LDFLAGS)
+#_xraylib_la_CPPFLAGS = -mdll
+endif
 
 dist_bin_SCRIPTS = xraylib
 nodist_python_PYTHON = xraylib.py xrayhelp.py xraymessages.py
@@ -32,14 +36,18 @@ pyexec_LTLIBRARIES += xraylib_np.la
 xraylib_np_la_CFLAGS = $(PYTHON_CFLAGS) -I$(top_srcdir)/include $(PYTHON_CPPFLAGS) $(NUMPY_HEADERS)
 xraylib_np_la_LIBADD = ../src/libxrl.la
 nodist_xraylib_np_la_SOURCES = xraylib_np.c
-xraylib_np_la_LDFLAGS = -avoid-version -module -shared -export-dynamic
+xraylib_np_la_LDFLAGS = $(LDFLAGS_PYTHON) -avoid-version -module -shared -export-dynamic -shrext $(PYTHON_EXT)
+if OS_WINDOWS
+xraylib_np_la_LDFLAGS += $(PYTHON_LDFLAGS)
+#xraylib_np_la_CPPFLAGS = -mdll
+endif
 endif
 
 xraylib_np.c: ${srcdir}/xraylib_np.pyx ${srcdir}/xraylib_np_c.pxd
-	$(CYTHON) -X boundscheck=False,wraparound=False -I${top_srcdir}/include -o ${builddir}/xraylib_np.c ${srcdir}/xraylib_np.pyx
+	$(CYTHON) -X boundscheck=False,wraparound=False,cdivision=True -I${top_srcdir}/include -o ${builddir}/xraylib_np.c ${srcdir}/xraylib_np.pyx
 
 xraylib_wrap.c: ${top_srcdir}/src/xraylib.i ${top_srcdir}/include/xraylib*h
-	$(SWIG) -I${top_srcdir}/include -includeall -o xraylib_wrap.c -python ${top_srcdir}/src/xraylib.i
+	$(SWIG) -DVERSION="'$(VERSION)'" -I${top_srcdir}/include -I$(srcdir) -I${top_builddir} -includeall -o xraylib_wrap.c -python ${top_srcdir}/src/xraylib.i
 
 xraylib.py: xraylib_wrap.c
 
@@ -49,4 +57,4 @@ clean-local:
 distclean-local:
 	rm -rf __pycache__
 
-EXTRA_DIST = xraylib_np_c.pxd xraylib_np.pyx
+EXTRA_DIST = xraylib_np_c.pxd xraylib_np.pyx pyfragments.swg
diff --git a/python/pyfragments.swg b/python/pyfragments.swg
index e69de29..901e6ed 100644
--- a/python/pyfragments.swg
+++ b/python/pyfragments.swg
@@ -0,0 +1,126 @@
+/*-*- C -*-*/
+
+/**********************************************************************/
+
+/* For numpy versions prior to 1.0, the names of certain data types
+ * are different than in later versions.  This fragment provides macro
+ * substitutions that allow us to support old and new versions of
+ * numpy.
+ */
+
+/**********************************************************************/
+
+/* Override the SWIG_AsVal_frag(long) fragment so that it also checks
+ * for numpy scalar array types.  The code through the %#endif is
+ * essentially cut-and-paste from pyprimtype.swg
+ */
+
+%fragment(SWIG_AsVal_frag(long), "header",
+	  fragment="SWIG_CanCastAsInteger",
+          fragment="NumPy_Backward_Compatibility")
+{
+  SWIGINTERN int
+  SWIG_AsVal_dec(long)(PyObject * obj, long * val)
+  {
+    PyArray_Descr * longDescr = PyArray_DescrNewFromType(NPY_LONG);
+    if (PyInt_Check(obj)) {
+      if (val) *val = PyInt_AsLong(obj);
+      return SWIG_OK;
+    } else if (PyLong_Check(obj)) {
+      long v = PyLong_AsLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_OK;
+      } else {
+	PyErr_Clear();
+      }
+    }
+%#ifdef SWIG_PYTHON_CAST_MODE
+    {
+      int dispatch = 0;
+      long v = PyInt_AsLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_AddCast(SWIG_OK);
+      } else {
+	PyErr_Clear();
+      }
+      if (!dispatch) {
+	double d;
+	int res = SWIG_AddCast(SWIG_AsVal(double)(obj,&d));
+	if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
+	  if (val) *val = (long)(d);
+	  return res;
+	}
+      }
+    }
+%#endif
+    if (!PyArray_IsScalar(obj,Integer)) return SWIG_TypeError;
+    PyArray_CastScalarToCtype(obj, (void*)val, longDescr);
+    return SWIG_OK;
+  }
+}
+
+
+/* Override the SWIG_AsVal_frag(unsigned long) fragment so that it
+ * also checks for numpy scalar array types.  The code through the
+ * %#endif is essentially cut-and-paste from pyprimtype.swg
+ */
+
+%fragment(SWIG_AsVal_frag(unsigned long),"header",
+	  fragment="SWIG_CanCastAsInteger",
+          fragment="NumPy_Backward_Compatibility")
+{
+  SWIGINTERN int
+  SWIG_AsVal_dec(unsigned long)(PyObject *obj, unsigned long *val)
+  {
+    PyArray_Descr * ulongDescr = PyArray_DescrNewFromType(NPY_ULONG);
+    %#if PY_VERSION_HEX < 0x03000000
+    if (PyInt_Check(obj)) 
+    {
+      long v = PyInt_AsLong(obj);
+      if (v >= 0) 
+      {
+        if (val) *val = v;
+	    return SWIG_OK;
+      } 
+      else 
+      {
+	    return SWIG_OverflowError;
+      }
+    } else 
+    %#endif
+    if (PyLong_Check(obj)) {
+      unsigned long v = PyLong_AsUnsignedLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_OK;
+      } else {
+	PyErr_Clear();
+      }
+    }
+%#ifdef SWIG_PYTHON_CAST_MODE
+    {
+      int dispatch = 0;
+      unsigned long v = PyLong_AsUnsignedLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_AddCast(SWIG_OK);
+      } else {
+	PyErr_Clear();
+      }
+      if (!dispatch) {
+	double d;
+	int res = SWIG_AddCast(SWIG_AsVal(double)(obj,&d));
+	if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
+	  if (val) *val = (unsigned long)(d);
+	  return res;
+	}
+      }
+    }
+%#endif
+    if (!PyArray_IsScalar(obj,Integer)) return SWIG_TypeError;
+    PyArray_CastScalarToCtype(obj, (void*)val, ulongDescr);
+    return SWIG_OK;
+  }
+}
diff --git a/src/xraylib.i b/src/xraylib.i
index f964bbd..1a93eec 100644
--- a/src/xraylib.i
+++ b/src/xraylib.i
@@ -33,10 +33,20 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
 #endif
 %}
 
+#ifdef SWIGPYTHON
+%pythoncode {
+__version__ = VERSION 
+}
+#endif
+
 
 %{
 #ifdef SWIGPYTHON
+
 #undef c_abs
+/* include numpy headers */
+#include <numpy/ndarraytypes.h>
+#include <numpy/ndarrayobject.h>
 #endif
 
 #ifdef SWIGLUA
@@ -52,6 +62,17 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
 
 %}
 
+#ifdef SWIGPYTHON
+%init %{
+    import_array();
+%}
+#endif
+
+#if defined(SWIGPHP) && !defined(SWIGPHP5) && !defined(SWIGPHP7)
+/* hack to ensure PHP bindings will still get built with old SWIGs */
+#define SWIGPHP5
+#endif
+
 #if !defined(SWIGLUA) && !defined(SWIGPHP)
 %ignore c_abs;
 %ignore c_mul;
@@ -283,6 +304,19 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
                 }
                 lua_settable(L, -3);
 
+                lua_pushstring(L, "nAtoms");
+                lua_createtable(L, cd->nElements, 0);
+                for (i = 0 ; i < cd->nElements ; i++) {
+                        lua_pushinteger(L,i+1);
+                        lua_pushnumber(L,cd->nAtoms[i]);
+                        lua_settable(L,-3);
+                }
+                lua_settable(L, -3);
+
+                lua_pushstring(L, "molarMass");
+                lua_pushnumber(L, cd->molarMass);
+                lua_settable(L,-3);
+
                 lua_pushvalue(L, -1);
                 FreeCompoundData(cd);
                 SWIG_arg++;
@@ -1137,12 +1171,16 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
                 STORE_HASH("nAtomsAll", newSVnv(cd->nAtomsAll),hash)
                 AV *Elements = newAV();
                 AV *massFractions = newAV();
+                AV *nAtoms = newAV();
                 STORE_HASH("Elements", newRV_noinc((SV*) Elements),hash)
                 STORE_HASH("massFractions", newRV_noinc((SV*) massFractions),hash)
+                STORE_HASH("nAtoms", newRV_noinc((SV*) nAtoms),hash)
                 for (i = 0 ; i < cd->nElements ; i++) {
                         av_push(Elements, newSViv(cd->Elements[i]));
                         av_push(massFractions, newSVnv(cd->massFractions[i]));
+                        av_push(nAtoms, newSVnv(cd->nAtoms[i]));
                 }
+                STORE_HASH("molarMass", newSVnv(cd->molarMass),hash)
                 FreeCompoundData(cd);
 
                 $result = sv_2mortal(newRV_noinc((SV*) hash));
@@ -1521,15 +1559,19 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
                 rv = rb_hash_new();
                 rb_hash_aset(rv, rb_str_new2("nElements"), INT2FIX(cd->nElements));
                 rb_hash_aset(rv, rb_str_new2("nAtomsAll"), rb_float_new(cd->nAtomsAll));
-                VALUE elements, massFractions;
+                VALUE elements, massFractions, nAtoms;
                 elements = rb_ary_new2(cd->nElements);
                 massFractions = rb_ary_new2(cd->nElements);
+                nAtoms = rb_ary_new2(cd->nElements);
                 for (i = 0 ; i < cd->nElements ; i++) {
                         rb_ary_store(elements, (long) i , INT2FIX(cd->Elements[i]));
                         rb_ary_store(massFractions, (long) i , rb_float_new(cd->massFractions[i]));
+                        rb_ary_store(nAtoms, (long) i , rb_float_new(cd->nAtoms[i]));
                 }
                 rb_hash_aset(rv, rb_str_new2("Elements"), elements);
                 rb_hash_aset(rv, rb_str_new2("massFractions"), massFractions);
+                rb_hash_aset(rv, rb_str_new2("nAtoms"), nAtoms);
+                rb_hash_aset(rv, rb_str_new2("molarMass"), rb_float_new(cd->molarMass));
                 FreeCompoundData(cd);
                 $result = rv;
         }
@@ -1725,7 +1767,7 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
 #endif
 
 
-#ifdef SWIGPHP
+#ifdef SWIGPHP5
 
 %typemap(out) char ** {
         int i = 0;
@@ -1817,18 +1859,23 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
         array_init(return_value);
         add_assoc_long(return_value, "nElements", cd->nElements);
         add_assoc_double(return_value, "nAtomsAll", cd->nAtomsAll);
-        zval *Elements, *massFractions;
+        zval *Elements, *massFractions, *nAtoms;
 
         ALLOC_INIT_ZVAL(Elements);
         ALLOC_INIT_ZVAL(massFractions);
+        ALLOC_INIT_ZVAL(nAtoms);
         array_init(Elements);
         array_init(massFractions);
+        array_init(nAtoms);
         for (i = 0 ; i < cd->nElements ; i++) {
                 add_index_long(Elements, i, cd->Elements[i]);
                 add_index_double(massFractions, i, cd->massFractions[i]);
+                add_index_double(nAtoms, i, cd->nAtoms[i]);
         }
         add_assoc_zval(return_value, "Elements", Elements);
         add_assoc_zval(return_value, "massFractions", massFractions);
+        add_assoc_zval(return_value, "nAtoms", nAtoms);
+        add_assoc_double(return_value, "molarMass", cd->molarMass);
         FreeCompoundData(cd);
 }
 
@@ -2018,4 +2065,291 @@ THIS SOFTWARE IS PROVIDED BY Bruno Golosio, Antonio Brunetti, Manuel Sanchez del
 }
 #endif
 
+#ifdef SWIGPHP7
+
+%typemap(out) char ** {
+        int i = 0;
+        char **list = $1;
+
+        array_init(return_value);
+        for (i = 0 ; list[i] != NULL ; i++) {
+                add_index_string(return_value, i, list[i]);
+                xrlFree(list[i]);
+        }
+        xrlFree(list);
+}
+
+%typemap(out) struct radioNuclideData * {
+        int i;
+        struct radioNuclideData *rnd = $1;
+
+        if (rnd == NULL) {
+                php_log_err("Error: requested radionuclide not found in database\n");
+                RETURN_NULL();
+        }
+        array_init(return_value);
+        add_assoc_string(return_value, "name", rnd->name);
+        add_assoc_long(return_value, "Z", rnd->Z);
+        add_assoc_long(return_value, "A", rnd->A);
+        add_assoc_long(return_value, "N", rnd->N);
+        add_assoc_long(return_value, "Z_xray", rnd->Z_xray);
+        add_assoc_long(return_value, "nXrays", rnd->nXrays);
+        add_assoc_long(return_value, "nGammas", rnd->nGammas);
+        zval XrayLines, XrayIntensities, GammaEnergies, GammaIntensities;
+
+        array_init(&XrayLines);
+        array_init(&XrayIntensities);
+        array_init(&GammaEnergies);
+        array_init(&GammaIntensities);
+        for (i = 0 ; i < rnd->nXrays ; i++) {
+                add_index_long(&XrayLines, i, rnd->XrayLines[i]);
+                add_index_double(&XrayIntensities, i, rnd->XrayIntensities[i]);
+        }
+        for (i = 0 ; i < rnd->nGammas ; i++) {
+                add_index_double(&GammaEnergies, i, rnd->GammaEnergies[i]);
+                add_index_double(&GammaIntensities, i, rnd->GammaIntensities[i]);
+        }
+        add_assoc_zval(return_value, "XrayLines", &XrayLines);
+        add_assoc_zval(return_value, "XrayIntensities", &XrayIntensities);
+        add_assoc_zval(return_value, "GammaEnergies", &GammaEnergies);
+        add_assoc_zval(return_value, "GammaIntensities", &GammaIntensities);
+        FreeRadioNuclideData(rnd);
+}
+%typemap(out) struct compoundDataNIST * {
+        int i;
+        struct compoundDataNIST *cdn = $1;
+
+        if (cdn == NULL) {
+                php_log_err("Error: requested NIST compound not found in database\n");
+                RETURN_NULL();
+        }
+        array_init(return_value);
+        add_assoc_string(return_value, "name", cdn->name);
+        add_assoc_long(return_value, "nElements", cdn->nElements);
+        add_assoc_double(return_value, "density", cdn->density);
+        zval Elements, massFractions;
+
+        array_init(&Elements);
+        array_init(&massFractions);
+        for (i = 0 ; i < cdn->nElements ; i++) {
+                add_index_long(&Elements, i, cdn->Elements[i]);
+                add_index_double(&massFractions, i, cdn->massFractions[i]);
+        }
+        add_assoc_zval(return_value, "Elements", &Elements);
+        add_assoc_zval(return_value, "massFractions", &massFractions);
+        FreeCompoundDataNIST(cdn);
+}
+%typemap(out) struct compoundData * {
+        int i;
+        struct compoundData *cd = $1;
+
+        if (cd == NULL) {
+                php_log_err("CompoundParser Error\n");
+                RETURN_NULL();
+        }
+        array_init(return_value);
+        add_assoc_long(return_value, "nElements", cd->nElements);
+        add_assoc_double(return_value, "nAtomsAll", cd->nAtomsAll);
+        zval Elements, massFractions, nAtoms;
+
+        array_init(&Elements);
+        array_init(&massFractions);
+        array_init(&nAtoms);
+        for (i = 0 ; i < cd->nElements ; i++) {
+                add_index_long(&Elements, i, cd->Elements[i]);
+                add_index_double(&massFractions, i, cd->massFractions[i]);
+                add_index_double(&nAtoms, i, cd->nAtoms[i]);
+        }
+        add_assoc_zval(return_value, "Elements", &Elements);
+        add_assoc_zval(return_value, "massFractions", &massFractions);
+        add_assoc_zval(return_value, "nAtoms", &nAtoms);
+        add_assoc_double(return_value, "molarMass", cd->molarMass);
+        FreeCompoundData(cd);
+}
+%typemap(out) xrlComplex {
+        xrlComplex c = $1;
+
+        array_init(return_value);
+        add_assoc_double(return_value, "re", c.re);
+        add_assoc_double(return_value, "im", c.im);
+}
+%typemap(in) xrlComplex {
+        xrlComplex c;
+
+        if (Z_TYPE($input) != IS_ARRAY) {
+                SWIG_exception(SWIG_TypeError,"Argument must be an array");
+        }
+        if (!zend_hash_str_exists(Z_ARRVAL($input), "im", sizeof("im")-1)) {
+                SWIG_exception(SWIG_TypeError, "re hash key not present");
+        }
+        if (!zend_hash_str_exists(Z_ARRVAL($input), "im", sizeof("im")-1)) {
+                SWIG_exception(SWIG_TypeError, "im hash key not present");
+        }
+        zval *re, *im;
+        re = zend_hash_str_find(Z_ARRVAL($input), "re", sizeof("re")-1);
+        im = zend_hash_str_find(Z_ARRVAL($input), "im", sizeof("im")-1);
+        convert_to_double_ex(re);
+        convert_to_double_ex(im);
+        c.re = Z_DVAL_P(re);
+        c.im = Z_DVAL_P(im);
+        $1 = c;
+}
+%typemap(out) Crystal_Struct * {
+        Crystal_Struct *cs = $1;
+        int i;
+        if (cs == NULL) {
+                php_log_err("Crystal_GetCrystal Error: crystal not found");
+                RETURN_NULL();
+        }
+
+        array_init(return_value);
+        add_assoc_string(return_value, "name", cs->name);
+        add_assoc_double(return_value, "a", cs->a);
+        add_assoc_double(return_value, "b", cs->b);
+        add_assoc_double(return_value, "c", cs->c);
+        add_assoc_double(return_value, "alpha", cs->alpha);
+        add_assoc_double(return_value, "beta", cs->beta);
+        add_assoc_double(return_value, "gamma", cs->gamma);
+        add_assoc_double(return_value, "volume", cs->volume);
+        add_assoc_long(return_value, "n_atom", cs->n_atom);
+        zval atom;
+        array_init(&atom);
+        add_assoc_zval(return_value, "atom", &atom);
+        for (i = 0 ; i < cs->n_atom ; i++) {
+                zval dict_temp;
+                array_init(&dict_temp);
+                add_assoc_long(&dict_temp, "Zatom", cs->atom[i].Zatom);
+                add_assoc_double(&dict_temp, "fraction", cs->atom[i].fraction);
+                add_assoc_double(&dict_temp, "x", cs->atom[i].x);
+                add_assoc_double(&dict_temp, "y", cs->atom[i].y);
+                add_assoc_double(&dict_temp, "z", cs->atom[i].z);
+                add_index_zval(&atom, i, &dict_temp);
+        }
+        add_assoc_long(return_value, "cpointer", (zend_long) cs);
+}
+%typemap(in) Crystal_Struct * {
+        /* cpointer should be used if present and valid */
+
+        if (Z_TYPE($input) != IS_ARRAY) {
+                SWIG_exception(SWIG_TypeError,"Argument must be an array");
+        }
+        if (zend_hash_str_exists(Z_ARRVAL($input), "cpointer", sizeof("cpointer")-1)) {
+                /* cpointer found */
+                zval *cpointer;
+                cpointer = zend_hash_str_find(Z_ARRVAL($input), "cpointer", sizeof("cpointer")-1);
+                convert_to_long_ex(cpointer);
+                Crystal_Struct *cs = (Crystal_Struct *) Z_LVAL_P(cpointer);
+                $1 = cs;
+        }
+        else {
+                Crystal_Struct *cs = malloc(sizeof(Crystal_Struct));
+                zval *temp;
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "name", sizeof("name")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"Name key not present");
+                }
+                cs->name = strdup(Z_STRVAL_P(temp));
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "a", sizeof("a")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"a key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->a = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "b", sizeof("b")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"b key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->b = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "c", sizeof("c")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"c key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->c = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "alpha", sizeof("alpha")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"alpha key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->alpha = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "beta", sizeof("beta")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"beta key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->beta= Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "gamma", sizeof("gamma")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"gamma key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->gamma = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "volume", sizeof("volume")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"volume key not present");
+                }
+                convert_to_double_ex(temp);
+                cs->volume = Z_DVAL_P(temp);
+
+                if ((temp = zend_hash_str_find(Z_ARRVAL($input), "n_atom", sizeof("n_atom")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"n_atom key not present");
+                }
+                convert_to_long_ex(temp);
+                cs->n_atom = (int) Z_LVAL_P(temp);
+
+                zval *atom;
+
+                if ((atom = zend_hash_str_find(Z_ARRVAL($input), "atom", sizeof("atom")-1)) == NULL) {
+                        SWIG_exception(SWIG_TypeError,"atom key not present");
+                }
+
+                if (Z_TYPE_P(atom) != IS_ARRAY) {
+                        SWIG_exception(SWIG_TypeError,"atom must be an array");
+                }
+                int i;
+                cs->atom = (Crystal_Atom *) malloc(sizeof(Crystal_Atom)*cs->n_atom);
+                for (i = 0 ; i < cs->n_atom ; i++) {
+                        zval *this_atom;
+                        if ((this_atom = zend_hash_index_find(Z_ARRVAL_P(atom), i)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"atom member not found\n");
+                        }
+                        zval *temp2;
+                        if ((temp2 = zend_hash_str_find(Z_ARRVAL_P(this_atom), "Zatom", sizeof("Zatom")-1)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"Zatom key not found\n");
+                        }
+                        convert_to_long_ex(temp2);
+                        cs->atom[i].Zatom = (int) Z_LVAL_P(temp2);
+
+                        if ((temp2 = zend_hash_str_find(Z_ARRVAL_P(this_atom), "fraction", sizeof("fraction")-1)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"fraction key not found\n");
+                        }
+                        convert_to_double_ex(temp2);
+                        cs->atom[i].fraction = (double) Z_DVAL_P(temp2);
+
+                        if ((temp2 = zend_hash_str_find(Z_ARRVAL_P(this_atom), "x", sizeof("x")-1)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"x key not found\n");
+                        }
+                        convert_to_double_ex(temp2);
+                        cs->atom[i].x = (double) Z_DVAL_P(temp2);
+
+                        if ((temp2 = zend_hash_str_find(Z_ARRVAL_P(this_atom), "y", sizeof("y")-1)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"y key not found\n");
+                        }
+                        convert_to_double_ex(temp2);
+                        cs->atom[i].y = (double) Z_DVAL_P(temp2);
+
+                        if ((temp2 = zend_hash_str_find(Z_ARRVAL_P(this_atom), "z", sizeof("z")-1)) == NULL) {
+                                SWIG_exception(SWIG_TypeError,"z key not found\n");
+                        }
+                        convert_to_double_ex(temp2);
+                        cs->atom[i].z = (double) Z_DVAL_P(temp2);
+
+                }
+                $1 = cs;
+        }
+
+}
+#endif
+
+
 %include "xraylib.h"
diff --git a/src/Makefile.am b/src/Makefile.am
index c91d5b0..80561b8 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -14,9 +14,14 @@ xraylibincludedir=${includedir}/xraylib
 AM_CPPFLAGS = -I${top_srcdir}/include -I${top_builddir}/include -I..
 
 
+if LIBXRL_CONVENIENCE_BUILD
+noinst_LTLIBRARIES = libxrl.la libprdata.la
+else
 lib_LTLIBRARIES=libxrl.la
-noinst_PROGRAMS=prdata
 noinst_LTLIBRARIES = libprdata.la
+endif
+
+noinst_PROGRAMS=prdata
 prdata_SOURCES = pr_data.c
 prdata_LDADD = libprdata.la
 libprdata_la_CFLAGS = $(AM_CFLAGS) $(ARCHFLAGS)
